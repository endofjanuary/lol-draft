"use client";

import { useState, useEffect, useCallback } from "react";
import { useParams } from "next/navigation";
import { io, Socket } from "socket.io-client";
import NicknameModal from "@/components/game/NicknameModal";
import LobbyPhase from "@/components/game/LobbyPhase";
import DraftPhase from "@/components/game/DraftPhase";
import ResultPhase from "@/components/game/ResultPhase";
import SideChoicePhase from "@/components/game/SideChoicePhase";
import { GameInfo, Player } from "@/types/game";
import { getApiBaseUrl, getSocketUrl } from "@/utils/apiConfig";
import {
  getStoredSocketId,
  storeSocketId,
  clearSocketSession,
  SESSION_KEYS,
} from "@/utils/sessionStorage";

export default function GamePage() {
  const { id } = useParams();
  const [socket, setSocket] = useState<Socket | null>(null);
  const [showNicknameModal, setShowNicknameModal] = useState(true);
  const [nickname, setNickname] = useState("");
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [gameInfo, setGameInfo] = useState<GameInfo | null>(null);
  const [position, setPosition] = useState<string>("spectator");
  const [isHost, setIsHost] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [lastLeftPlayer, setLastLeftPlayer] = useState<{
    nickname: string;
    position: string;
  } | null>(null);
  const [clientId, setClientId] = useState<string>("");
  const [hasAttemptedJoin, setHasAttemptedJoin] = useState(false);

  // ÏßÑÏòÅ ÏÑ†ÌÉù Í¥ÄÎ†® ÏÉÅÌÉú
  const [showSideChoice, setShowSideChoice] = useState(false);
  const [losingSide, setLosingSide] = useState<"blue" | "red" | null>(null);

  // Initialize client-side data after component mounts (SSR-safe)
  useEffect(() => {
    console.log("Initializing client-side data...");
    if (typeof window !== "undefined") {
      // Í∞úÎ∞ú/ÌÖåÏä§Ìä∏Ïö© Ìó¨Ìçº Ìï®Ïàò Îì±Î°ù
      (window as any).clearGameSession = () => {
        sessionStorage.removeItem(SESSION_KEYS.NICKNAME);
        sessionStorage.removeItem(SESSION_KEYS.CLIENT_ID);
        sessionStorage.removeItem(SESSION_KEYS.GAME_CODE);
        console.log("Game session cleared. Refresh the page to start fresh.");
        window.location.reload();
      };

      // ÌòÑÏû¨ Í≤åÏûÑ ÏΩîÎìúÏôÄ Ï†ÄÏû•Îêú Í≤åÏûÑ ÏΩîÎìú ÎπÑÍµê
      const storedGameCode =
        sessionStorage.getItem(SESSION_KEYS.GAME_CODE) || "";
      const storedNickname =
        sessionStorage.getItem(SESSION_KEYS.NICKNAME) || "";
      const storedClientId =
        sessionStorage.getItem(SESSION_KEYS.CLIENT_ID) || "";

      console.log("Stored game code:", storedGameCode);
      console.log("Current game code:", id);
      console.log("Stored nickname:", storedNickname);
      console.log("Stored client ID:", storedClientId);
      console.log("üí° Tip: Run clearGameSession() in console to reset session");

      // Îã§Î•∏ Í≤åÏûÑÏóêÏÑú ÏôîÍ±∞ÎÇò Ï≤òÏùå Ï†ëÏÜçÌïòÎäî Í≤ΩÏö∞
      if (storedGameCode !== id) {
        console.log(
          "Different game or first visit, clearing session and showing nickname modal"
        );
        // ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï¥àÍ∏∞Ìôî
        sessionStorage.removeItem(SESSION_KEYS.NICKNAME);
        sessionStorage.removeItem(SESSION_KEYS.CLIENT_ID);
        sessionStorage.removeItem(SESSION_KEYS.GAME_CODE);

        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        setNickname("");
        setClientId("");
        setShowNicknameModal(true);
        setHasAttemptedJoin(false);
        setGameInfo(null);
        setPosition("spectator");
        setIsHost(false);
      } else if (storedNickname) {
        // Í∞ôÏùÄ Í≤åÏûÑÏóêÏÑú Ïû¨Ï†ëÏÜçÌïú Í≤ΩÏö∞
        console.log("Returning to same game with stored nickname");
        setNickname(storedNickname);
        setClientId(storedClientId);
        // Ï†ÄÏû•Îêú ÎãâÎÑ§ÏûÑÏù¥ ÏûàÏñ¥ÎèÑ ÏÇ¨Ïö©ÏûêÍ∞Ä Îã§Î•∏ ÎãâÎÑ§ÏûÑÏùÑ ÏÑ†ÌÉùÌï† Ïàò ÏûàÎèÑÎ°ù Î™®Îã¨ ÌëúÏãú
        setShowNicknameModal(true);
        setHasAttemptedJoin(false); // Ïû¨Ï†ëÏÜç ÏãúÏóêÎäî Îã§Ïãú Ï∞∏Í∞Ä ÏãúÎèÑ ÌóàÏö©
      } else {
        // Í∞ôÏùÄ Í≤åÏûÑÏù¥ÏßÄÎßå ÎãâÎÑ§ÏûÑÏù¥ ÏóÜÎäî Í≤ΩÏö∞
        console.log("Same game but no stored nickname, showing modal");
        setShowNicknameModal(true);
        setHasAttemptedJoin(false);
      }
    }
  }, [id]); // idÎ•º ÏùòÏ°¥ÏÑ±ÏúºÎ°ú Ï∂îÍ∞ÄÌïòÏó¨ Í≤åÏûÑ ÏΩîÎìú Î≥ÄÍ≤Ω Ïãú Ïû¨Ïã§Ìñâ

  // Fetch game info
  const fetchGameInfo = useCallback(async () => {
    console.log("fetchGameInfo called");
    try {
      setIsLoading(true);
      const apiBaseUrl = getApiBaseUrl();
      const url = `${apiBaseUrl}/games/${id}`;
      console.log(`Fetching game info from: ${url}`);

      const response = await fetch(url);
      console.log("API response status:", response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error("API error response:", errorText);
        throw new Error(
          `API request failed with status ${response.status}: ${errorText}`
        );
      }

      const data = await response.json();
      console.log("Game info loaded successfully:", data);
      console.log("Game version:", data.settings?.version);

      setGameInfo(data);

      // Update host status and position based on clientId
      if (data.clients && clientId) {
        const currentPlayer = data.clients.find(
          (p: Player) => p.clientId === clientId
        );
        if (currentPlayer) {
          setIsHost(currentPlayer.isHost);
          setPosition(currentPlayer.position);
          console.log("Current player info:", {
            nickname: currentPlayer.nickname,
            position: currentPlayer.position,
            isHost: currentPlayer.isHost,
          });
        } else {
          console.log("Current player not found in clients list");
        }
      } else {
        console.log("No clients data or clientId not available");
      }
    } catch (error) {
      console.error("Failed to fetch game info:", error);

      // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
      if (error instanceof TypeError && error.message.includes("fetch")) {
        const apiBaseUrl = getApiBaseUrl();
        console.warn(
          `Î∞±ÏóîÎìú ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Mock Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§. (${apiBaseUrl})`
        );

        // Mock Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
        const mockGameInfo = {
          game: {
            gameCode: id as string,
            createdAt: Date.now(),
          },
          settings: {
            version: "15.11.1",
            draftType: "tournament",
            playerType: "1v1",
            matchFormat: "bo1",
            timeLimit: true,
            globalBans: [],
            bannerImage: undefined,
          },
          status: {
            phase: 0,
            phaseData: Array(21).fill(""),
            team1Name: "Team 1",
            team2Name: "Team 2",
            team1Side: "blue" as const,
            team2Side: "red" as const,
            lastUpdatedAt: Date.now(),
            setNumber: 1,
            // ÌïòÏúÑ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú ÌïÑÎìúÎì§
            blueTeamName: "Team 1",
            redTeamName: "Team 2",
          },
          clients: [],
          team1Score: 0,
          team2Score: 0,
          // ÌïòÏúÑ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú ÌïÑÎìúÎì§
          blueScore: 0,
          redScore: 0,
        };

        console.log("Using mock game info:", mockGameInfo);
        setGameInfo(mockGameInfo);

        // Mock ÌôòÍ≤ΩÏóêÏÑúÎäî ÏûêÎèôÏúºÎ°ú Ìò∏Ïä§Ìä∏Î°ú ÏÑ§Ï†ï (Îã®, ÏïÑÏßÅ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞Îßå)
        if (!isHost) {
          setIsHost(true);
        }
        if (position === "spectator") {
          setPosition("team1");
        }
      } else {
        setError(
          `Í≤åÏûÑ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${
            error instanceof Error ? error.message : "Unknown error"
          }`
        );
      }
    } finally {
      setIsLoading(false);
    }
  }, [id, clientId, isHost, position]);

  // Handle join game - prevent duplicate calls
  const handleJoinGame = useCallback(
    (userNickname: string) => {
      console.log("handleJoinGame called with nickname:", userNickname);

      // Prevent duplicate calls
      if (isLoading || hasAttemptedJoin) {
        console.log(
          "Already loading or already attempted join, skipping duplicate join request"
        );
        return;
      }

      if (!socket || !userNickname.trim()) {
        console.log("Socket not available or nickname empty, fallback to mock");
        // ÏÜåÏºìÏù¥ ÏóÜÎäî Í≤ΩÏö∞ mock ÌôòÍ≤ΩÏúºÎ°ú Ï≤òÎ¶¨
        setNickname(userNickname);
        sessionStorage.setItem(SESSION_KEYS.NICKNAME, userNickname);
        sessionStorage.setItem(SESSION_KEYS.GAME_CODE, id as string);
        setShowNicknameModal(false);
        setHasAttemptedJoin(true);

        // Mock ÌôòÍ≤ΩÏóêÏÑú Í≤åÏûÑ Ï†ïÎ≥¥ ÏßÅÏ†ë Î°úÎìú
        fetchGameInfo();
        return;
      }

      // Check if already joined (has game info and position is not spectator)
      if (gameInfo && position !== "spectator") {
        console.log("Already joined game, fetching latest info instead");
        fetchGameInfo();
        return;
      }

      setNickname(userNickname);
      sessionStorage.setItem(SESSION_KEYS.NICKNAME, userNickname);
      sessionStorage.setItem(SESSION_KEYS.GAME_CODE, id as string);
      setIsLoading(true);
      setHasAttemptedJoin(true);

      console.log("Emitting join_game event...");
      socket.emit(
        "join_game",
        {
          gameCode: id,
          nickname: userNickname,
          position: "spectator",
          socketId: getStoredSocketId(),
        },
        (response: any) => {
          console.log("Join game response:", response);
          if (response.status === "success") {
            setShowNicknameModal(false);

            // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID Ï†ÄÏû•
            if (response.data?.clientId) {
              setClientId(response.data.clientId);
              sessionStorage.setItem(
                SESSION_KEYS.CLIENT_ID,
                response.data.clientId
              );
            }

            if (response.data?.position) {
              setPosition(response.data.position);
            }
            if (response.data?.isHost !== undefined) {
              setIsHost(response.data.isHost);
            }
            // Í≤åÏûÑ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Í∏∞ Ï†ÑÏóê Ïû†Ïãú ÎåÄÍ∏∞
            console.log("Join successful, fetching game info in 500ms...");
            setTimeout(() => {
              fetchGameInfo();
            }, 500);
          } else {
            console.error("Join game failed:", response.message);
            // ÏÜåÏºì Ï∞∏Í∞ÄÏóê Ïã§Ìå®Ìïú Í≤ΩÏö∞ mock ÌôòÍ≤ΩÏúºÎ°ú fallback
            console.log("Falling back to mock environment");
            setShowNicknameModal(false);
            fetchGameInfo();
          }
          setIsLoading(false);
        }
      );
    },
    [socket, id, isLoading, gameInfo, position, fetchGameInfo, hasAttemptedJoin]
  );

  // Auto-join when socket connects and nickname is available
  useEffect(() => {
    console.log("Checking auto-join conditions:", {
      isConnected,
      nickname: !!nickname,
      gameId: id,
      showNicknameModal,
      gameInfo: !!gameInfo,
      position,
      hasAttemptedJoin,
    });

    // ÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÍ≥†, ÎãâÎÑ§ÏûÑÏù¥ ÏûàÍ≥†, Î™®Îã¨Ïù¥ Ïà®Í≤®ÏßÑ ÏÉÅÌÉúÏù¥Î©∞, ÏïÑÏßÅ Í≤åÏûÑÏóê Ï∞∏Í∞ÄÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞Îßå ÏûêÎèô Ï∞∏Í∞Ä
    if (
      isConnected &&
      nickname &&
      !showNicknameModal &&
      id &&
      socket &&
      !gameInfo && // Í≤åÏûÑ Ï†ïÎ≥¥Í∞Ä ÏóÜÏùÑ ÎïåÎßå ÏûêÎèô Ï∞∏Í∞Ä
      position === "spectator" && // ÏïÑÏßÅ ÌåÄÏóê Ï∞∏Í∞ÄÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
      !hasAttemptedJoin // ÏïÑÏßÅ Ï∞∏Í∞ÄÎ•º ÏãúÎèÑÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
    ) {
      console.log("Auto-joining game with stored credentials...");
      setHasAttemptedJoin(true); // Ï∞∏Í∞Ä ÏãúÎèÑ ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
      handleJoinGame(nickname);
    }
  }, [
    isConnected,
    nickname,
    showNicknameModal,
    id,
    socket,
    gameInfo,
    position,
    hasAttemptedJoin,
    handleJoinGame,
  ]);

  // Connect to socket.io server
  useEffect(() => {
    const socketUrl = getSocketUrl();
    const storedSocketId = getStoredSocketId();

    const socketInstance = io(socketUrl, {
      transports: ["websocket"],
      autoConnect: true,
      auth: storedSocketId ? { socketId: storedSocketId } : undefined,
    });

    socketInstance.on("connect", () => {
      console.log("Socket connected");
      setIsConnected(true);
    });

    socketInstance.on("connection_success", (data) => {
      console.log("Connection successful, socket ID:", data.sid);
      storeSocketId(data.sid);

      // ÏûêÎèô Ïû¨Ï†ëÏÜç Î°úÏßÅÏùÄ Î≥ÑÎèÑ useEffectÏóêÏÑú Ï≤òÎ¶¨
    });

    socketInstance.on("disconnect", () => {
      console.log("Socket disconnected");
      setIsConnected(false);
    });

    socketInstance.on("connect_error", (error) => {
      console.error("Connection error:", error);
      setError("ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
    });

    // Listen for game events
    socketInstance.on("draft_started", () => {
      fetchGameInfo();
    });

    socketInstance.on("phase_progressed", (data) => {
      console.log("Phase progressed event:", data);
      // data: { gameCode, confirmedBy, fromPhase, toPhase, confirmedChampion, timestamp }

      // gameInfoÍ∞Ä ÏûàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏
      setGameInfo((prevGameInfo) => {
        if (!prevGameInfo) return prevGameInfo;

        // ÏÉàÎ°úÏö¥ phaseData Î∞∞Ïó¥ ÏÉùÏÑ±
        const newPhaseData = [...prevGameInfo.status.phaseData];

        // ÌôïÏ†ïÎêú Ï±îÌîºÏñ∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (data.confirmedChampion && data.fromPhase < newPhaseData.length) {
          newPhaseData[data.fromPhase] = data.confirmedChampion;
        }

        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Ï†ïÎ≥¥ Î∞òÌôò
        return {
          ...prevGameInfo,
          status: {
            ...prevGameInfo.status,
            phase: data.toPhase,
            phaseData: newPhaseData,
            lastUpdatedAt: data.timestamp,
          },
        };
      });

      // ÏÉà ÌéòÏù¥Ï¶àÎ°ú ÏßÑÌñâÎê† Îïå DraftPhase Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÌéòÏù¥Ï¶à Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ Î∞úÏÉù
      // Ïù¥ Ïù¥Î≤§Ìä∏Îäî DraftPhase Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏàòÏã†ÌïòÏó¨ ÏÑ†ÌÉùÎêú Ï±îÌîºÏñ∏ ÏÉÅÌÉú Ï¥àÍ∏∞ÌôîÏóê ÏÇ¨Ïö©
      if (socket) {
        // ÏÜåÏºì Ïù¥Î≤§Ìä∏ Î∞úÏÉù ÎåÄÏã† Ïª§Ïä§ÌÖÄ Ïù¥Î≤§Ìä∏ ÌôúÏö©
        const phaseChangeEvent = new CustomEvent("phaseChanged", {
          detail: { fromPhase: data.fromPhase, toPhase: data.toPhase },
        });
        window.dispatchEvent(phaseChangeEvent);
      }
    });

    socketInstance.on("game_result_confirmed", () => {
      fetchGameInfo();
    });

    // ÏßÑÏòÅ ÏÑ†ÌÉù Í¥ÄÎ†® Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    socketInstance.on("side_choice_phase", (data) => {
      console.log("Side choice phase started:", data);
      setLosingSide(data.losingSide);
      setShowSideChoice(true);
    });

    socketInstance.on("next_set_started", (data) => {
      console.log("Next set started:", data);
      setShowSideChoice(false);
      setLosingSide(null);
      // Í≤åÏûÑ Ï†ïÎ≥¥ ÏÉàÎ°úÍ≥†Ïπ®
      fetchGameInfo();
    });

    socketInstance.on("match_finished", (data) => {
      console.log("Match finished:", data);
      setShowSideChoice(false);
      setLosingSide(null);
      // Í≤åÏûÑ Ï†ïÎ≥¥ ÏÉàÎ°úÍ≥†Ïπ®
      fetchGameInfo();
    });

    socketInstance.on("client_joined", (data) => {
      console.log("Client joined event:", data);

      // gameInfoÍ∞Ä ÏûàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏
      setGameInfo((prevGameInfo) => {
        if (!prevGameInfo) return prevGameInfo;

        // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
        const existingClientIndex = prevGameInfo.clients.findIndex(
          (client) => client.nickname === data.nickname
        );

        let updatedClients;

        if (existingClientIndex >= 0) {
          // Ï°¥Ïû¨ÌïòÎäî ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î©¥ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
          updatedClients = [...prevGameInfo.clients];
          updatedClients[existingClientIndex] = {
            ...updatedClients[existingClientIndex],
            position: data.position,
            isHost: data.isHost,
          };
        } else {
          // ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î©¥ Ï∂îÍ∞Ä
          updatedClients = [
            ...prevGameInfo.clients,
            {
              nickname: data.nickname,
              position: data.position,
              isReady: false, // Ï¥àÍ∏∞Í∞í ÏÑ§Ï†ï
              isHost: data.isHost,
              clientId: data.clientId, // clientIdÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
            },
          ];
        }

        return {
          ...prevGameInfo,
          clients: updatedClients,
        };
      });
    });

    socketInstance.on("position_changed", (data) => {
      console.log("Position changed event:", data);
      // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò Ìè¨ÏßÄÏÖòÏù¥ Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞
      if (data.nickname === nickname) {
        setPosition(data.newPosition);
      }

      // gameInfoÍ∞Ä ÏûàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏
      setGameInfo((prevGameInfo) => {
        if (!prevGameInfo) return prevGameInfo;

        // clients Î∞∞Ïó¥ ÏóÖÎç∞Ïù¥Ìä∏
        const updatedClients = prevGameInfo.clients.map((client) => {
          if (client.nickname === data.nickname) {
            return { ...client, position: data.newPosition };
          }
          return client;
        });

        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Ï†ïÎ≥¥ Î∞òÌôò
        return {
          ...prevGameInfo,
          clients: updatedClients,
        };
      });
    });

    socketInstance.on("ready_state_changed", (data) => {
      console.log("Ready state changed event:", data);

      // gameInfoÍ∞Ä ÏûàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏
      setGameInfo((prevGameInfo) => {
        if (!prevGameInfo) return prevGameInfo;

        // clients Î∞∞Ïó¥ ÏóÖÎç∞Ïù¥Ìä∏
        const updatedClients = prevGameInfo.clients.map((client) => {
          if (
            client.nickname === data.nickname &&
            client.position === data.position
          ) {
            return { ...client, isReady: data.isReady };
          }
          return client;
        });

        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Ï†ïÎ≥¥ Î∞òÌôò
        return {
          ...prevGameInfo,
          clients: updatedClients,
        };
      });
    });

    socketInstance.on("client_left", (data) => {
      console.log(
        `${data.nickname} left the game (position: ${data.position})`
      );
      setLastLeftPlayer(data);

      // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù¥ÌÉà Ïãú gameInfo ÏóÖÎç∞Ïù¥Ìä∏
      setGameInfo((prevGameInfo) => {
        if (!prevGameInfo) return prevGameInfo;

        // clients Î∞∞Ïó¥ÏóêÏÑú Ìï¥Îãπ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†úÍ±∞
        const updatedClients = prevGameInfo.clients.filter(
          (client) =>
            !(
              client.nickname === data.nickname &&
              client.position === data.position
            )
        );

        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Ï†ïÎ≥¥ Î∞òÌôò
        return {
          ...prevGameInfo,
          clients: updatedClients,
        };
      });

      setTimeout(() => setLastLeftPlayer(null), 5000);
    });

    setSocket(socketInstance);

    return () => {
      socketInstance.disconnect();
    };
  }, []);

  // Í≤åÏûÑ Ï¢ÖÎ£å ÎòêÎäî Ìá¥Ïû• Ïãú ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï†ïÎ¶¨
  const handleLeaveGame = () => {
    clearSocketSession();
    if (socket) {
      socket.disconnect();
    }
  };

  // Handle position change
  const handlePositionChange = (newPosition: string) => {
    if (!socket) return;

    // Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò Ï†ÄÏû•
    const oldPosition = position;

    // Ï¶âÏãú UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Î°úÏª¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω
    setPosition(newPosition);

    // Set loading to prevent multiple clicks
    setIsLoading(true);

    socket.emit(
      "change_position",
      { position: newPosition },
      (response: any) => {
        if (response.status === "success") {
          console.log(`Position changed to ${newPosition}`);

          // ÎÇ¥ Î°úÏª¨ ÏÉÅÌÉú Î∞è gameInfoÏùò clients Î∞∞Ïó¥ ÏóÖÎç∞Ïù¥Ìä∏
          if (gameInfo) {
            setGameInfo((prevGameInfo) => {
              if (!prevGameInfo) return prevGameInfo;

              // clients Î∞∞Ïó¥ÏóêÏÑú ÎÇ¥ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
              const updatedClients = prevGameInfo.clients.map((client) => {
                // clientIdÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏Î°ú ÎπÑÍµê, ÏóÜÏúºÎ©¥ ÎãâÎÑ§ÏûÑÏúºÎ°ú ÎπÑÍµê
                const isCurrentUser =
                  (clientId && client.clientId === clientId) ||
                  (!clientId && client.nickname === nickname);
                if (isCurrentUser) {
                  return { ...client, position: newPosition };
                }
                return client;
              });

              return {
                ...prevGameInfo,
                clients: updatedClients,
              };
            });
          }
        } else {
          // Ïã§Ìå® Ïãú Ïù¥Ï†Ñ Ìè¨ÏßÄÏÖòÏúºÎ°ú ÎêòÎèåÎ¶º
          setPosition(oldPosition);
          setError(response.message || "Ìè¨ÏßÄÏÖò Î≥ÄÍ≤ΩÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        }
        setIsLoading(false);
      }
    );
  };

  // Handle ready state change
  const handleReadyChange = (isReady: boolean) => {
    if (!socket) return;

    // Set loading to prevent multiple clicks
    setIsLoading(true);

    // Î°úÏª¨ UI Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
    setGameInfo((prevGameInfo) => {
      if (!prevGameInfo) return prevGameInfo;

      // clients Î∞∞Ïó¥ÏóêÏÑú ÎÇ¥ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      const updatedClients = prevGameInfo.clients.map((client) => {
        // clientIdÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏Î°ú ÎπÑÍµê, ÏóÜÏúºÎ©¥ ÎãâÎÑ§ÏûÑÏúºÎ°ú ÎπÑÍµê
        const isCurrentUser =
          (clientId && client.clientId === clientId) ||
          (!clientId && client.nickname === nickname);

        // ÎÇ¥ ÏúÑÏπòÍ∞Ä Í∞ôÏùÄ Í≤ΩÏö∞Îßå ÏóÖÎç∞Ïù¥Ìä∏ (ÏúÑÏπòÍ∞Ä Î∞îÎÄåÏóàÏùÑ Ïàò ÏûàÏùå)
        if (isCurrentUser && client.position === position) {
          return { ...client, isReady };
        }
        return client;
      });

      return {
        ...prevGameInfo,
        clients: updatedClients,
      };
    });

    socket.emit("change_ready_state", { isReady }, (response: any) => {
      if (response.status !== "success") {
        setError(response.message || "Ï§ÄÎπÑ ÏÉÅÌÉú Î≥ÄÍ≤ΩÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");

        // Ïã§Ìå® Ïãú Ïù¥Ï†Ñ ÏÉÅÌÉúÎ°ú ÎêòÎèåÎ¶¨Í∏∞ ÏúÑÌï¥ gameInfo Îã§Ïãú Í∞ÄÏ†∏Ïò§Í∏∞
        fetchGameInfo();
      }
      setIsLoading(false);
    });
  };

  // Handle start draft
  const handleStartDraft = () => {
    if (!socket || !isHost) return;

    socket.emit("start_draft", {}, (response: any) => {
      if (response.status !== "success") {
        setError(response.message || "Í≤åÏûÑ ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      }
    });
  };

  // Handle champion selection
  const handleSelectChampion = (champion: string) => {
    if (!socket) return;

    // Validate the champion before sending
    if (!champion || typeof champion !== "string" || champion.trim() === "") {
      setError("Ïú†Ìö®Ìïú Ï±îÌîºÏñ∏ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }

    console.log(`Sending champion selection: ${champion}`); // Debug log

    socket.emit("select_champion", { champion }, (response: any) => {
      console.log("Selection response:", response); // Debug log
      if (response.status !== "success") {
        setError(response.message || "Ï±îÌîºÏñ∏ ÏÑ†ÌÉùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      }
    });
  };

  // Handle selection confirmation
  const handleConfirmSelection = () => {
    if (!socket || !gameInfo) return;

    console.log("Sending selection confirmation"); // Debug log

    // ÌòÑÏû¨ phase Ï†ïÎ≥¥ Ï†ÄÏû•
    const currentPhase = gameInfo.status.phase;

    // ÌéòÏù¥Ï¶àÍ∞Ä Î≥ÄÍ≤ΩÎêòÍ∏∞ Ï†ÑÏóê ÏÑ†ÌÉù ÏÉÅÌÉúÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÎèÑÎ°ù ÎØ∏Î¶¨ Ïª§Ïä§ÌÖÄ Ïù¥Î≤§Ìä∏ Î∞úÏÉùÏãúÌÇ¥
    // Ïù¥ Ïù¥Î≤§Ìä∏Îäî DraftPhase Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏàòÏã†ÌïòÏó¨ ÏÑ†ÌÉùÎêú Ï±îÌîºÏñ∏ ÏÉÅÌÉú Ï¥àÍ∏∞ÌôîÏóê ÏÇ¨Ïö©
    const phaseChangeEvent = new CustomEvent("resetSelections", {});
    window.dispatchEvent(phaseChangeEvent);

    // ÏÑúÎ≤ÑÏóê ÌôïÏ†ï ÏöîÏ≤≠
    socket.emit("confirm_selection", {}, (response: any) => {
      console.log("Confirmation response:", response); // Debug log
      if (response.status !== "success") {
        setError(response.message || "ÏÑ†ÌÉù ÌôïÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        // Ïã§Ìå® Ïãú ÏõêÎûò ÏÉÅÌÉúÎ°ú Î≥µÏõêÌïòÍ∏∞ ÏúÑÌï¥ Í≤åÏûÑ Ï†ïÎ≥¥ Îã§Ïãú Í∞ÄÏ†∏Ïò§Í∏∞
        fetchGameInfo();
      } else {
        console.log("Selection confirmed successfully");
      }
    });
  };

  // Handle game result confirmation
  const handleConfirmResult = (winner: string) => {
    if (!socket || !isHost) return;

    socket.emit("confirm_result", { winner }, (response: any) => {
      if (response.status !== "success") {
        setError(response.message || "Í≤åÏûÑ Í≤∞Í≥º ÌôïÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      } else {
        console.log("Game result confirmed successfully");
        // Fetch game info to update scores
        fetchGameInfo();
      }
    });
  };

  // Handle side choice
  const handleSideChoice = (choice: "keep" | "swap") => {
    if (!socket || !isHost) return;

    socket.emit(
      "choose_side",
      {
        gameCode: id,
        choice: choice,
      },
      (response: any) => {
        if (response.status !== "success") {
          setError(response.message || "ÏßÑÏòÅ ÏÑ†ÌÉùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        } else {
          console.log("Side choice confirmed successfully");
        }
      }
    );
  };

  // Handle moving to next game (in a series)
  const handleNextGame = () => {
    if (!socket || !isHost || !gameInfo) return;

    // ÎßàÏßÄÎßâ ÏÑ∏Ìä∏Ïù∏ÏßÄ ÌôïÏù∏ÌïòÎäî Î°úÏßÅ
    const isFinalSet = (() => {
      const matchFormat = gameInfo.settings.matchFormat || "bo1";
      const currentSet = gameInfo.status.setNumber || 1;
      const blueScore = gameInfo.blueScore || 0;
      const redScore = gameInfo.redScore || 0;

      // Îã®ÌåêÏ†úÏù∏ Í≤ΩÏö∞
      if (matchFormat === "bo1") return true;

      // 3Ìåê 2ÏÑ†ÏäπÏ†ú
      if (matchFormat === "bo3") {
        if (blueScore >= 2 || redScore >= 2 || currentSet >= 3) return true;
      }

      // 5Ìåê 3ÏÑ†ÏäπÏ†ú
      if (matchFormat === "bo5") {
        if (blueScore >= 3 || redScore >= 3 || currentSet >= 5) return true;
      }

      return false;
    })();

    // ÎßàÏßÄÎßâ ÏÑ∏Ìä∏Ïù∏ Í≤ΩÏö∞ Îã§Ïùå Í≤åÏûÑÏúºÎ°ú Ïù¥ÎèôÌïòÏßÄ ÏïäÏùå
    if (isFinalSet) {
      console.log(
        "ÏµúÏ¢Ö ÏÑ∏Ìä∏Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. Îçî Ïù¥ÏÉÅ ÏßÑÌñâÌï† ÏÑ∏Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§."
      );
      return;
    }

    socket.emit("prepare_next_game", {}, (response: any) => {
      if (response.status !== "success") {
        setError(response.message || "Îã§Ïùå Í≤åÏûÑ Ï§ÄÎπÑÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      } else {
        console.log("Next game preparation successful");
        fetchGameInfo();
      }
    });
  };

  // Show loading state if not connected
  if (!isConnected) {
    console.log("Not connected, showing connection loading state");
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-[#030C28] text-white">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>
        <p>ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ Ï§ëÏûÖÎãàÎã§...</p>
      </div>
    );
  }

  // Render game content based on phase
  const renderGameContent = () => {
    console.log("renderGameContent called", {
      isLoading,
      gameInfo: !!gameInfo,
      showNicknameModal,
    });

    // Show loading while fetching game info
    if (isLoading) {
      console.log("Showing loading state");
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>
          <p className="ml-3">Í≤åÏûÑ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...</p>
        </div>
      );
    }

    // If game info is not available yet
    if (!gameInfo) {
      console.log("No game info available yet");
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <p className="text-gray-400 mb-4">
              Í≤åÏûÑ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...
            </p>
            <button
              onClick={() => {
                console.log("Manual fetch game info button clicked");
                fetchGameInfo();
              }}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md"
            >
              Í≤åÏûÑ Ï†ïÎ≥¥ Îã§Ïãú Î∂àÎü¨Ïò§Í∏∞
            </button>
          </div>
        </div>
      );
    }

    // Ensure we have the necessary gameInfo structure
    if (!gameInfo.status) {
      console.log("Game info status not available");
      return (
        <div className="flex items-center justify-center min-h-screen">
          <p className="text-gray-400">
            Í≤åÏûÑ Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.
          </p>
        </div>
      );
    }

    // ÏßÑÏòÅ ÏÑ†ÌÉù ÌéòÏù¥Ï¶à ÌëúÏãú
    if (showSideChoice && losingSide) {
      return (
        <SideChoicePhase
          gameInfo={gameInfo}
          losingSide={losingSide}
          onSideChoice={handleSideChoice}
          isHost={isHost}
        />
      );
    }

    // Solo game (to be implemented later)
    if (gameInfo.settings.playerType === "single") {
      return (
        <div className="flex items-center justify-center min-h-screen">
          <p className="text-gray-400">ÏÜîÎ°ú Í≤åÏûÑ Í∏∞Îä•ÏùÄ ÌòÑÏû¨ Í∞úÎ∞ú Ï§ëÏûÖÎãàÎã§.</p>
        </div>
      );
    }

    // For 1v1 or 5v5 games, show different UI based on phase
    const phase = gameInfo.status.phase;

    if (phase === 0) {
      // Lobby phase - ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID Ï†ÑÎã¨
      return (
        <LobbyPhase
          gameInfo={gameInfo}
          gameId={id as string}
          position={position}
          isHost={isHost}
          players={gameInfo.clients || []}
          onPositionChange={handlePositionChange}
          onReadyChange={handleReadyChange}
          onStartDraft={handleStartDraft}
          nickname={nickname}
          clientId={clientId} // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID Ï†ÑÎã¨
        />
      );
    } else if (phase >= 1 && phase <= 20) {
      // Draft phase
      return (
        <DraftPhase
          gameInfo={gameInfo}
          nickname={nickname}
          position={position}
          onSelectChampion={handleSelectChampion}
          onConfirmSelection={handleConfirmSelection}
          socket={socket}
        />
      );
    } else if (phase === 21) {
      // Result phase
      return (
        <ResultPhase
          gameInfo={gameInfo}
          onConfirmResult={handleConfirmResult}
          onNextGame={handleNextGame}
          isHost={isHost}
        />
      );
    } else if (phase === 22) {
      // Side choice phase (handled above)
      return (
        <div className="flex items-center justify-center min-h-screen">
          <p className="text-gray-400">ÏßÑÏòÅ ÏÑ†ÌÉù Ï§ëÏûÖÎãàÎã§...</p>
        </div>
      );
    } else if (phase === 23) {
      // Match finished
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <h2 className="text-3xl font-bold mb-4">Í≤ΩÍ∏∞ Ï¢ÖÎ£å</h2>
            <p className="text-xl mb-8">Î™®Îì† Í≤ΩÍ∏∞Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!</p>
            <button
              onClick={() => (window.location.href = "/")}
              className="px-8 py-4 bg-green-600 hover:bg-green-700 rounded-lg font-bold text-lg"
            >
              Î©îÏù∏ ÌéòÏù¥ÏßÄÎ°ú
            </button>
          </div>
        </div>
      );
    }

    return null;
  };

  return (
    <div className="min-h-screen bg-[#030C28] text-white">
      {/* Error message display */}
      {error && (
        <div className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md z-50">
          {error}
          <button className="ml-2 font-bold" onClick={() => setError(null)}>
            ‚úï
          </button>
        </div>
      )}

      {/* Player left notification */}
      {lastLeftPlayer && (
        <div className="fixed top-16 left-1/2 transform -translate-x-1/2 bg-yellow-600 text-white px-4 py-2 rounded-md z-50 transition-opacity">
          {lastLeftPlayer.nickname}ÎãòÏù¥ Í≤åÏûÑÏóêÏÑú ÎÇòÍ∞îÏäµÎãàÎã§. (Ìè¨ÏßÄÏÖò:{" "}
          {lastLeftPlayer.position === "spectator"
            ? "Í¥ÄÏ†ÑÏûê"
            : lastLeftPlayer.position === "team1"
            ? "Team 1"
            : lastLeftPlayer.position === "team2"
            ? "Team 2"
            : lastLeftPlayer.position}
          )
        </div>
      )}

      {/* Nickname Modal */}
      {showNicknameModal && (
        <NicknameModal
          onSubmit={handleJoinGame}
          currentNickname={nickname || undefined}
        />
      )}

      {/* Game Content based on phase */}
      {!showNicknameModal && renderGameContent()}
    </div>
  );
}
